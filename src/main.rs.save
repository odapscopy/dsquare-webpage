use axum::{
    extract::State, // new code
    http::StatusCode,
    response::{Html, IntoResponse},
    routing::get,
    Router,
};
//use std::net::SocketAddr;
use std::{env, net::SocketAddr, path::PathBuf, sync::Arc}; // new code
// use tokio::signal;
use tower_http::{cors::{CorsLayer, Any}, compression::CompressionLayer, services::ServeDir, trace::TraceLayer};

// new code
#[derive(Clone)]
struct AppState {
    content_dir: Arc<PathBuf>,
}

#[tokio::main]
async fn main() {
    // Initialize tracing for request logging
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::INFO)
        .init();
    
    // new code
    // Get content directory from environment variable or use current directory
    let content_dir = env::var("CONTENT_DIR")
        .map(PathBuf::from)
        .unwrap_or_else(|_| env::current_dir().expect("Failed to get current directory"));
    
    // new code
    tracing::info!("Serving content from: {}", content_dir.display());
    
    // new code
    let state = AppState {
        content_dir: Arc::new(content_dir.clone()),
    };

    // Create our service router
    let app = Router::new()
        .route("/", get(serve_index))
        .route("/index", get(serve_home))
        .route("/services", get(serve_services))
        .route("/contact-us", get(serve_contact))
        .route("/about-us", get(serve_about_us))
        //.nest_service("/pages", ServeDir::new("pages").precompressed_gzip())
        .nest_service("/pages", ServeDir::new(content_dir.join("pages")).precompressed_gzip()) // new code
        //.nest_service("/assets", ServeDir::new("assets").precompressed_gzip())
        .nest_service("/assets", ServeDir::new(content_dir.join("assets")).append_index_html_on_director) // new code
        //.nest_service("/styles", ServeDir::new("styles").precompressed_gzip())
        .nest_service("/styles", ServeDir::new(content_dir.join("styles")).precompressed_gzip()) // new code
        .fallback(handle_404)
        // Add middleware for all routes
        .layer(
            CorsLayer::new()
                .allow_origin(Any)
                .allow_methods(Any)
                .allow_headers(Any)
        )
        .layer(TraceLayer::new_for_http())
        .layer(CompressionLayer::new())
        .with_state(state); // new code
    
    let addr = SocketAddr::from(([0, 0, 0, 0], 8090));
    tracing::info!("ðŸš€ Server listening on {}", addr);

    // Build the server with graceful shutdown
    let listener = tokio::net::TcpListener::bind(&addr).await.unwrap();
    /*let server = axum::Server::bind(&addr)
    .serve(app.into_make_service())
    .with_graceful_shutdown(shutdown_signal());*/
    axum::serve(listener, app).await.unwrap();

    // Start the server and handle any errors
    /*if let Err(e) = server.await {
        tracing::error!("Server error: {}", e);
    }*/
}

/*async fn serve_index() -> Result<Html<String>, AppError> {
    serve_file("../index.html")
}*/
// new code
async fn serve_index(State(state): State<AppState>) -> Result<Html<String>, AppError> {
    serve_file(state.content_dir.join("index.html"))
}

/*async fn serve_home() -> Result<Html<String>, AppError> {
    serve_file("pages/home.html")
}*/
// new code
async fn serve_home(State(state): State<AppState>) -> Result<Html<String>, AppError> {
    serve_file(state.content_dir.join("pages/home.html"))
}

/*async fn serve_services() -> Result<Html<String>, AppError> {
    serve_file("pages/services.html")
}*/
// new code
async fn serve_services(State(state): State<AppState>) -> Result<Html<String>, AppError> {
    serve_file(state.content_dir.join("pages/services.html"))
}

/*async fn serve_contact() -> Result<Html<String>, AppError> {
    serve_file("pages/contact-us.html")
}*/
// new code
async fn serve_contact(State(state): State<AppState>) -> Result<Html<String>, AppError> {
    serve_file(state.content_dir.join("pages/contact-us.html"))
}

/*async fn serve_about_us() -> Result<Html<String>, AppError> {
    serve_file("pages/about-us.html")
}*/
// new code
async fn serve_about_us(State(state): State<AppState>) -> Result<Html<String>, AppError> {
    serve_file(state.content_dir.join("pages/about-us.html"))
}

/*fn serve_file(path: &str) -> Result<Html<String>, AppError> {
    std::fs::read_to_string(path)
        .map(Html)
        .map_err(|_| AppError::NotFound)
}*/
// new code
fn serve_file(path: PathBuf) -> Result<Html<String>, AppError> {
    std::fs::read_to_string(&path).map(Html).map_err(|e| {
        tracing::error!("Failed to read {}: {}", path.display(), e);
        AppError::NotFound
    })
}

/*async fn handle_404() -> impl IntoResponse {
    (
        StatusCode::NOT_FOUND,
        Html(
            std::fs::read_to_string("pages/404.html")
                .unwrap_or_else(|_| String::from("Si vous plair! Page not found")),
        ),
    )
}*/
// new code
async fn handle_404(State(state): State<AppState>) -> impl IntoResponse {
    let not_found_path = state.content_dir.join("pages/404.html");
    (
        StatusCode::NOT_FOUND,
        Html(
            std::fs::read_to_string(&not_found_path)
                .unwrap_or_else(|_| String::from("Page not found")),
        ),
    )
}

#[derive(Debug)]
enum AppError {
    NotFound,
}

/*impl IntoResponse for AppError {
    fn into_response(self) -> axum::response::Response {
        (
            StatusCode::NOT_FOUND,
            Html(
                std::fs::read_to_string("pages/404.html")
                    .unwrap_or_else(|_| String::from("Epele! Page not found")),
            ),
        )
            .into_response()
    }
}*/
// new code
impl IntoResponse for AppError {
    fn into_response(self) -> axum::response::Response {
        (StatusCode::NOT_FOUND, Html(String::from("Page not found"))).into_response()
    }
}
